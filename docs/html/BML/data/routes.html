<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>BML.data.routes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>BML.data.routes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import sys, os, time
from _pybgpstream import BGPStream, BGPRecord, BGPElem
from threading import Thread
import ipaddress as ip
import json
from BML.utils import utils

class RoutesDump(Thread):

        def __init__(self):

                Thread.__init__(self)

                self.startTime = -1
                self.endTime = -1

                self.projects = [&#39;ris&#39;,&#39;routeviews&#39;]
                self.collectors = []
                self.ipVersion = [4,6]

                self.stream = BGPStream()

                self.routes = {}
                self.currentTime = -1
                self.finished = False
                self.terminate = False

                self.updates = None
                self.updatesFilePath = None

        def setProjects(self, projects):
                self.projects = projects

        def setIpVersion(self, ipVersion):
                self.ipVersion = ipVersion

        def setCollectors(self, collectors):
                self.collectors = collectors

        def setInterval(self, start, end):
                self.startTime = start
                self.endTime = end

        def setUpdates(self, updates):
                self.updates = updates

        def setUpdatesFile(self, filePath):
                self.updatesFilePath = filePath

        def startStream(self):

                if(self.startTime!=-1 and self.endTime!=-1):

                        for project in self.projects:
                                self.stream.add_filter(&#39;project&#39;, project)

                        if(len(self.collectors)&gt;0):
                                for collector in self.collectors:
                                        self.stream.add_filter(&#39;collector&#39;, collector)

                        self.stream.add_interval_filter(self.startTime,self.endTime)
                        self.stream.add_filter(&#39;record-type&#39;,&#39;updates&#39;)

                        self.stream.start()
                else:
                        quit(&#34;Error: can&#39;t start stream, interval not set&#34;)

        def getProgress(self):
                progress = 0
                if(self.currentTime!=-1):
                        progress = (self.currentTime-self.startTime)*100//(self.endTime-self.startTime)
                return(progress)
                
        def isRunning(self):
                return(not self.finished)

        def stop(self):
                self.terminate = True


        def dumpUpdate(self, u):

                self.currentTime = int(u[&#39;time&#39;])

                if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;W&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                        collector = u[&#39;collector&#39;]
                        peer = u[&#39;peer_asn&#39;]
                        fields = json.loads(u[&#39;fields&#39;])
                        prefix = fields[&#39;prefix&#39;]

                        network = ip.ip_network(prefix)
                        if(network.version in self.ipVersion):

                                if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                                        if(prefix not in self.routes):
                                                self.routes[prefix] = {}
                                        if(collector not in self.routes[prefix]):
                                                self.routes[prefix][collector] = {}

                                        self.routes[prefix][collector][peer] = fields[&#39;as-path&#39;]


                                elif(u[&#39;type&#39;]==&#39;W&#39;):

                                        if(prefix in self.routes and collector in self.routes[prefix] and  peer in self.routes[prefix][collector]):
                                                self.routes[prefix][collector][peer] = None


        def buildRoutesDump(self):

                record = BGPRecord()

                while(self.stream.get_next_record(record) and not self.terminate):

                        if record.status == &#34;valid&#34;:

                                elem = record.get_next_elem()

                                while(elem and not self.terminate):

                                        u= {}

                                        u[&#39;collector&#39;] = str(record.collector)
                                        u[&#39;dump_time&#39;] = str(record.dump_time)
                                        u[&#39;type&#39;] = str(elem.type)
                                        u[&#39;time&#39;] = str(elem.time)
                                        u[&#39;peer_address&#39;] = str(elem.peer_address)
                                        u[&#39;peer_asn&#39;] = str(elem.peer_asn)
                                        u[&#39;fields&#39;] = json.dumps(elem.fields)

                                        self.dumpUpdate(u)
                                        
                                        elem = record.get_next_elem()

                self.finished = True

        def buildRoutesDumpFromUpdates(self):

                if(len(self.updates)==1):
                        return

                headerLine = &#34;&#34;
                firstLine = &#34;&#34;
                lastLine = &#34;&#34;
                
                i = 0
                for line in self.updates:
                        if(i==0):
                                headerLine = line
                        if(i==1):
                                firstLine = line

                        i+= 1
                lastLine = line

                header = {}
                headerSplited = headerLine.split(&#39;,&#39;)
                nbItems = len(headerSplited)
                for i in range(len(headerSplited)):
                        header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

                self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
                self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

                i=0
                for line in self.updates:

                        if(i!=0):

                                lineSplited = line.split(&#39;,&#39;)
                                lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                                u= {}

                                u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                                u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                                u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                                u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                                u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                                u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                                u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]

                                self.dumpUpdate(u)

                        i+=1
                
                self.finished = True
        

        def buildRoutesDumpFromUpdatesFile(self):

                headerLine = &#34;&#34;
                firstLine = &#34;&#34;
                lastLine = &#34;&#34;
                
                with open(self.updatesFilePath) as file:

                        i = 0
                        for line in file:
                                if(i==0):
                                        headerLine = line
                                if(i==1):
                                        firstLine = line

                                i+= 1


                        lastLine = line
                        file.close()

                header = {}
                headerSplited = headerLine.split(&#39;,&#39;)
                nbItems = len(headerSplited)
                for i in range(len(headerSplited)):
                        header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

                self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
                self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

                with open(self.updatesFilePath) as file:

                        i=0
                        for line in file:

                                if(i!=0):

                                        lineSplited = line.split(&#39;,&#39;)
                                        lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                                        u= {}

                                        u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                                        u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                                        u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                                        u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                                        u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                                        u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                                        u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]


                                        self.dumpUpdate(u)

                                i+=1
                
                self.finished = True


        def getOutputFilename(self):
                return(&#34;routes.json&#34;)


        def saveTo(self, path):

                filePath = utils.mkdirPath(path) + self.getOutputFilename()

                file = open(filePath,&#34;w&#34;)
                json.dump(self.routes, file)
                file.close()

                return(filePath)


        def run(self):

                if(self.updates!=None):
                        self.buildRoutesDumpFromUpdates()
                elif(self.updatesFilePath!=None):
                        self.buildRoutesDumpFromUpdatesFile()
                else:
                        self.startStream()
                        self.buildRoutesDump()


def dumpRoutes(start, end, folder, collectors, routes=None, logFiles=[], saveRoutes=True, updates=None, updatesDumpFile=None, returnRoutes=False, projects=[&#34;ris&#34;], ipVersion=[4,6]):

        logFile = open(utils.mkdirPath(folder)+&#34;log_routes_dump.log&#34;,&#39;w&#39;)
        logFiles.append(logFile)

        routesDump = RoutesDump()

        if(routes):
                routesDump.routes = routes

        try:

                routesDump.setInterval(start,end)
                routesDump.setProjects(projects)
                routesDump.setCollectors(collectors)
                routesDump.setUpdates(updates)
                routesDump.setUpdatesFile(updatesDumpFile)
                routesDump.setIpVersion(ipVersion)
                
                utils.printAndLog(&#34;#############&#34;, logFiles)
                utils.printAndLog(&#34;# Route dump&#34;, logFiles)
                utils.printAndLog(&#34;#############&#34;, logFiles)

                if(updates!=None):
                        utils.printAndLog(&#34;Nb. of Updates: &#34; + str(len(routesDump.updates)), logFiles)
                elif(updatesDumpFile!=None):
                        utils.printAndLog(&#34;Updates file: &#34; + str(routesDump.updatesFilePath), logFiles)
                else:
                        utils.printAndLog(&#34;Start time: &#34; + str(routesDump.startTime), logFiles)
                        utils.printAndLog(&#34;End time: &#34; + str(routesDump.endTime), logFiles)
                        utils.printAndLog(&#34;Duration: &#34; + utils.timeFormat(routesDump.endTime-routesDump.startTime), logFiles)
                        utils.printAndLog(&#34;Projects: &#34; + str(routesDump.projects), logFiles)
                        utils.printAndLog(&#34;Collectors: &#34; + str(routesDump.collectors), logFiles)
                utils.printAndLog(&#34;Ip version: &#34; + str(routesDump.ipVersion), logFiles)

                timeAtStart = time.time() 

                routesDump.start()
                
                utils.printProgress(routesDump, logFiles)

                utils.printAndLog(&#34;Computation time: &#34; + utils.timeFormat(time.time()-timeAtStart), logFiles)
                utils.printAndLog(&#34;Nb. of prefix in route dump: &#34; + str(len(routesDump.routes.keys())), logFiles)

                if(saveRoutes):
                        filePath = routesDump.saveTo(folder)
                        utils.printAndLog(&#34;Route dump saved to: &#34; + filePath, logFiles)

        except KeyboardInterrupt:
                utils.printAndLog(&#39;User interrupted, ask route dump to stop...&#39;, logFiles)
                routesDump.stop()
                quit()

        logFile.close()

        if(returnRoutes):
                return(routesDump.routes)
        else:
                return(filePath)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="BML.data.routes.dumpRoutes"><code class="name flex">
<span>def <span class="ident">dumpRoutes</span></span>(<span>start, end, folder, collectors, routes=None, logFiles=[], saveRoutes=True, updates=None, updatesDumpFile=None, returnRoutes=False, projects=['ris'], ipVersion=[4, 6])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumpRoutes(start, end, folder, collectors, routes=None, logFiles=[], saveRoutes=True, updates=None, updatesDumpFile=None, returnRoutes=False, projects=[&#34;ris&#34;], ipVersion=[4,6]):

        logFile = open(utils.mkdirPath(folder)+&#34;log_routes_dump.log&#34;,&#39;w&#39;)
        logFiles.append(logFile)

        routesDump = RoutesDump()

        if(routes):
                routesDump.routes = routes

        try:

                routesDump.setInterval(start,end)
                routesDump.setProjects(projects)
                routesDump.setCollectors(collectors)
                routesDump.setUpdates(updates)
                routesDump.setUpdatesFile(updatesDumpFile)
                routesDump.setIpVersion(ipVersion)
                
                utils.printAndLog(&#34;#############&#34;, logFiles)
                utils.printAndLog(&#34;# Route dump&#34;, logFiles)
                utils.printAndLog(&#34;#############&#34;, logFiles)

                if(updates!=None):
                        utils.printAndLog(&#34;Nb. of Updates: &#34; + str(len(routesDump.updates)), logFiles)
                elif(updatesDumpFile!=None):
                        utils.printAndLog(&#34;Updates file: &#34; + str(routesDump.updatesFilePath), logFiles)
                else:
                        utils.printAndLog(&#34;Start time: &#34; + str(routesDump.startTime), logFiles)
                        utils.printAndLog(&#34;End time: &#34; + str(routesDump.endTime), logFiles)
                        utils.printAndLog(&#34;Duration: &#34; + utils.timeFormat(routesDump.endTime-routesDump.startTime), logFiles)
                        utils.printAndLog(&#34;Projects: &#34; + str(routesDump.projects), logFiles)
                        utils.printAndLog(&#34;Collectors: &#34; + str(routesDump.collectors), logFiles)
                utils.printAndLog(&#34;Ip version: &#34; + str(routesDump.ipVersion), logFiles)

                timeAtStart = time.time() 

                routesDump.start()
                
                utils.printProgress(routesDump, logFiles)

                utils.printAndLog(&#34;Computation time: &#34; + utils.timeFormat(time.time()-timeAtStart), logFiles)
                utils.printAndLog(&#34;Nb. of prefix in route dump: &#34; + str(len(routesDump.routes.keys())), logFiles)

                if(saveRoutes):
                        filePath = routesDump.saveTo(folder)
                        utils.printAndLog(&#34;Route dump saved to: &#34; + filePath, logFiles)

        except KeyboardInterrupt:
                utils.printAndLog(&#39;User interrupted, ask route dump to stop...&#39;, logFiles)
                routesDump.stop()
                quit()

        logFile.close()

        if(returnRoutes):
                return(routesDump.routes)
        else:
                return(filePath)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="BML.data.routes.RoutesDump"><code class="flex name class">
<span>class <span class="ident">RoutesDump</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutesDump(Thread):

        def __init__(self):

                Thread.__init__(self)

                self.startTime = -1
                self.endTime = -1

                self.projects = [&#39;ris&#39;,&#39;routeviews&#39;]
                self.collectors = []
                self.ipVersion = [4,6]

                self.stream = BGPStream()

                self.routes = {}
                self.currentTime = -1
                self.finished = False
                self.terminate = False

                self.updates = None
                self.updatesFilePath = None

        def setProjects(self, projects):
                self.projects = projects

        def setIpVersion(self, ipVersion):
                self.ipVersion = ipVersion

        def setCollectors(self, collectors):
                self.collectors = collectors

        def setInterval(self, start, end):
                self.startTime = start
                self.endTime = end

        def setUpdates(self, updates):
                self.updates = updates

        def setUpdatesFile(self, filePath):
                self.updatesFilePath = filePath

        def startStream(self):

                if(self.startTime!=-1 and self.endTime!=-1):

                        for project in self.projects:
                                self.stream.add_filter(&#39;project&#39;, project)

                        if(len(self.collectors)&gt;0):
                                for collector in self.collectors:
                                        self.stream.add_filter(&#39;collector&#39;, collector)

                        self.stream.add_interval_filter(self.startTime,self.endTime)
                        self.stream.add_filter(&#39;record-type&#39;,&#39;updates&#39;)

                        self.stream.start()
                else:
                        quit(&#34;Error: can&#39;t start stream, interval not set&#34;)

        def getProgress(self):
                progress = 0
                if(self.currentTime!=-1):
                        progress = (self.currentTime-self.startTime)*100//(self.endTime-self.startTime)
                return(progress)
                
        def isRunning(self):
                return(not self.finished)

        def stop(self):
                self.terminate = True


        def dumpUpdate(self, u):

                self.currentTime = int(u[&#39;time&#39;])

                if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;W&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                        collector = u[&#39;collector&#39;]
                        peer = u[&#39;peer_asn&#39;]
                        fields = json.loads(u[&#39;fields&#39;])
                        prefix = fields[&#39;prefix&#39;]

                        network = ip.ip_network(prefix)
                        if(network.version in self.ipVersion):

                                if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                                        if(prefix not in self.routes):
                                                self.routes[prefix] = {}
                                        if(collector not in self.routes[prefix]):
                                                self.routes[prefix][collector] = {}

                                        self.routes[prefix][collector][peer] = fields[&#39;as-path&#39;]


                                elif(u[&#39;type&#39;]==&#39;W&#39;):

                                        if(prefix in self.routes and collector in self.routes[prefix] and  peer in self.routes[prefix][collector]):
                                                self.routes[prefix][collector][peer] = None


        def buildRoutesDump(self):

                record = BGPRecord()

                while(self.stream.get_next_record(record) and not self.terminate):

                        if record.status == &#34;valid&#34;:

                                elem = record.get_next_elem()

                                while(elem and not self.terminate):

                                        u= {}

                                        u[&#39;collector&#39;] = str(record.collector)
                                        u[&#39;dump_time&#39;] = str(record.dump_time)
                                        u[&#39;type&#39;] = str(elem.type)
                                        u[&#39;time&#39;] = str(elem.time)
                                        u[&#39;peer_address&#39;] = str(elem.peer_address)
                                        u[&#39;peer_asn&#39;] = str(elem.peer_asn)
                                        u[&#39;fields&#39;] = json.dumps(elem.fields)

                                        self.dumpUpdate(u)
                                        
                                        elem = record.get_next_elem()

                self.finished = True

        def buildRoutesDumpFromUpdates(self):

                if(len(self.updates)==1):
                        return

                headerLine = &#34;&#34;
                firstLine = &#34;&#34;
                lastLine = &#34;&#34;
                
                i = 0
                for line in self.updates:
                        if(i==0):
                                headerLine = line
                        if(i==1):
                                firstLine = line

                        i+= 1
                lastLine = line

                header = {}
                headerSplited = headerLine.split(&#39;,&#39;)
                nbItems = len(headerSplited)
                for i in range(len(headerSplited)):
                        header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

                self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
                self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

                i=0
                for line in self.updates:

                        if(i!=0):

                                lineSplited = line.split(&#39;,&#39;)
                                lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                                u= {}

                                u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                                u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                                u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                                u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                                u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                                u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                                u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]

                                self.dumpUpdate(u)

                        i+=1
                
                self.finished = True
        

        def buildRoutesDumpFromUpdatesFile(self):

                headerLine = &#34;&#34;
                firstLine = &#34;&#34;
                lastLine = &#34;&#34;
                
                with open(self.updatesFilePath) as file:

                        i = 0
                        for line in file:
                                if(i==0):
                                        headerLine = line
                                if(i==1):
                                        firstLine = line

                                i+= 1


                        lastLine = line
                        file.close()

                header = {}
                headerSplited = headerLine.split(&#39;,&#39;)
                nbItems = len(headerSplited)
                for i in range(len(headerSplited)):
                        header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

                self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
                self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

                with open(self.updatesFilePath) as file:

                        i=0
                        for line in file:

                                if(i!=0):

                                        lineSplited = line.split(&#39;,&#39;)
                                        lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                                        u= {}

                                        u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                                        u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                                        u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                                        u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                                        u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                                        u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                                        u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]


                                        self.dumpUpdate(u)

                                i+=1
                
                self.finished = True


        def getOutputFilename(self):
                return(&#34;routes.json&#34;)


        def saveTo(self, path):

                filePath = utils.mkdirPath(path) + self.getOutputFilename()

                file = open(filePath,&#34;w&#34;)
                json.dump(self.routes, file)
                file.close()

                return(filePath)


        def run(self):

                if(self.updates!=None):
                        self.buildRoutesDumpFromUpdates()
                elif(self.updatesFilePath!=None):
                        self.buildRoutesDumpFromUpdatesFile()
                else:
                        self.startStream()
                        self.buildRoutesDump()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="BML.data.routes.RoutesDump.buildRoutesDump"><code class="name flex">
<span>def <span class="ident">buildRoutesDump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildRoutesDump(self):

        record = BGPRecord()

        while(self.stream.get_next_record(record) and not self.terminate):

                if record.status == &#34;valid&#34;:

                        elem = record.get_next_elem()

                        while(elem and not self.terminate):

                                u= {}

                                u[&#39;collector&#39;] = str(record.collector)
                                u[&#39;dump_time&#39;] = str(record.dump_time)
                                u[&#39;type&#39;] = str(elem.type)
                                u[&#39;time&#39;] = str(elem.time)
                                u[&#39;peer_address&#39;] = str(elem.peer_address)
                                u[&#39;peer_asn&#39;] = str(elem.peer_asn)
                                u[&#39;fields&#39;] = json.dumps(elem.fields)

                                self.dumpUpdate(u)
                                
                                elem = record.get_next_elem()

        self.finished = True</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.buildRoutesDumpFromUpdates"><code class="name flex">
<span>def <span class="ident">buildRoutesDumpFromUpdates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildRoutesDumpFromUpdates(self):

        if(len(self.updates)==1):
                return

        headerLine = &#34;&#34;
        firstLine = &#34;&#34;
        lastLine = &#34;&#34;
        
        i = 0
        for line in self.updates:
                if(i==0):
                        headerLine = line
                if(i==1):
                        firstLine = line

                i+= 1
        lastLine = line

        header = {}
        headerSplited = headerLine.split(&#39;,&#39;)
        nbItems = len(headerSplited)
        for i in range(len(headerSplited)):
                header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

        self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
        self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

        i=0
        for line in self.updates:

                if(i!=0):

                        lineSplited = line.split(&#39;,&#39;)
                        lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                        u= {}

                        u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                        u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                        u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                        u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                        u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                        u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                        u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]

                        self.dumpUpdate(u)

                i+=1
        
        self.finished = True</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.buildRoutesDumpFromUpdatesFile"><code class="name flex">
<span>def <span class="ident">buildRoutesDumpFromUpdatesFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildRoutesDumpFromUpdatesFile(self):

        headerLine = &#34;&#34;
        firstLine = &#34;&#34;
        lastLine = &#34;&#34;
        
        with open(self.updatesFilePath) as file:

                i = 0
                for line in file:
                        if(i==0):
                                headerLine = line
                        if(i==1):
                                firstLine = line

                        i+= 1


                lastLine = line
                file.close()

        header = {}
        headerSplited = headerLine.split(&#39;,&#39;)
        nbItems = len(headerSplited)
        for i in range(len(headerSplited)):
                header[headerSplited[i].replace(&#39;\n&#39;,&#39;&#39;)] = i

        self.startTime = int(firstLine.split(&#39;,&#39;)[header[&#39;time&#39;]])
        self.endTime = int(lastLine.split(&#39;,&#39;)[header[&#39;time&#39;]])

        with open(self.updatesFilePath) as file:

                i=0
                for line in file:

                        if(i!=0):

                                lineSplited = line.split(&#39;,&#39;)
                                lineSplited[nbItems-1] = &#39;,&#39;.join(lineSplited[nbItems-1::])

                                u= {}

                                u[&#39;collector&#39;] = lineSplited[header[&#39;collector&#39;]]
                                u[&#39;dump_time&#39;] = lineSplited[header[&#39;dump_time&#39;]]
                                u[&#39;type&#39;] = lineSplited[header[&#39;type&#39;]]
                                u[&#39;time&#39;] = lineSplited[header[&#39;time&#39;]]
                                u[&#39;peer_address&#39;] = lineSplited[header[&#39;peer_address&#39;]]
                                u[&#39;peer_asn&#39;] = lineSplited[header[&#39;peer_asn&#39;]]
                                u[&#39;fields&#39;] = lineSplited[header[&#39;fields&#39;]]


                                self.dumpUpdate(u)

                        i+=1
        
        self.finished = True</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.dumpUpdate"><code class="name flex">
<span>def <span class="ident">dumpUpdate</span></span>(<span>self, u)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumpUpdate(self, u):

        self.currentTime = int(u[&#39;time&#39;])

        if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;W&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                collector = u[&#39;collector&#39;]
                peer = u[&#39;peer_asn&#39;]
                fields = json.loads(u[&#39;fields&#39;])
                prefix = fields[&#39;prefix&#39;]

                network = ip.ip_network(prefix)
                if(network.version in self.ipVersion):

                        if(u[&#39;type&#39;]==&#39;A&#39; or u[&#39;type&#39;]==&#39;R&#39;):

                                if(prefix not in self.routes):
                                        self.routes[prefix] = {}
                                if(collector not in self.routes[prefix]):
                                        self.routes[prefix][collector] = {}

                                self.routes[prefix][collector][peer] = fields[&#39;as-path&#39;]


                        elif(u[&#39;type&#39;]==&#39;W&#39;):

                                if(prefix in self.routes and collector in self.routes[prefix] and  peer in self.routes[prefix][collector]):
                                        self.routes[prefix][collector][peer] = None</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.getOutputFilename"><code class="name flex">
<span>def <span class="ident">getOutputFilename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOutputFilename(self):
        return(&#34;routes.json&#34;)</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.getProgress"><code class="name flex">
<span>def <span class="ident">getProgress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProgress(self):
        progress = 0
        if(self.currentTime!=-1):
                progress = (self.currentTime-self.startTime)*100//(self.endTime-self.startTime)
        return(progress)</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.isRunning"><code class="name flex">
<span>def <span class="ident">isRunning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isRunning(self):
        return(not self.finished)</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method representing the thread's activity.</p>
<p>You may override this method in a subclass. The standard run() method
invokes the callable object passed to the object's constructor as the
target argument, if any, with sequential and keyword arguments taken
from the args and kwargs arguments, respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):

        if(self.updates!=None):
                self.buildRoutesDumpFromUpdates()
        elif(self.updatesFilePath!=None):
                self.buildRoutesDumpFromUpdatesFile()
        else:
                self.startStream()
                self.buildRoutesDump()</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.saveTo"><code class="name flex">
<span>def <span class="ident">saveTo</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveTo(self, path):

        filePath = utils.mkdirPath(path) + self.getOutputFilename()

        file = open(filePath,&#34;w&#34;)
        json.dump(self.routes, file)
        file.close()

        return(filePath)</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setCollectors"><code class="name flex">
<span>def <span class="ident">setCollectors</span></span>(<span>self, collectors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCollectors(self, collectors):
        self.collectors = collectors</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setInterval"><code class="name flex">
<span>def <span class="ident">setInterval</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInterval(self, start, end):
        self.startTime = start
        self.endTime = end</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setIpVersion"><code class="name flex">
<span>def <span class="ident">setIpVersion</span></span>(<span>self, ipVersion)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIpVersion(self, ipVersion):
        self.ipVersion = ipVersion</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setProjects"><code class="name flex">
<span>def <span class="ident">setProjects</span></span>(<span>self, projects)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setProjects(self, projects):
        self.projects = projects</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setUpdates"><code class="name flex">
<span>def <span class="ident">setUpdates</span></span>(<span>self, updates)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpdates(self, updates):
        self.updates = updates</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.setUpdatesFile"><code class="name flex">
<span>def <span class="ident">setUpdatesFile</span></span>(<span>self, filePath)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUpdatesFile(self, filePath):
        self.updatesFilePath = filePath</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.startStream"><code class="name flex">
<span>def <span class="ident">startStream</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startStream(self):

        if(self.startTime!=-1 and self.endTime!=-1):

                for project in self.projects:
                        self.stream.add_filter(&#39;project&#39;, project)

                if(len(self.collectors)&gt;0):
                        for collector in self.collectors:
                                self.stream.add_filter(&#39;collector&#39;, collector)

                self.stream.add_interval_filter(self.startTime,self.endTime)
                self.stream.add_filter(&#39;record-type&#39;,&#39;updates&#39;)

                self.stream.start()
        else:
                quit(&#34;Error: can&#39;t start stream, interval not set&#34;)</code></pre>
</details>
</dd>
<dt id="BML.data.routes.RoutesDump.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
        self.terminate = True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="" style="font-size:4em;color:#058">BML</a>
<hr style="margin-top:30px;margin-bottom:30px;">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="BML.data" href="index.html">BML.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="BML.data.routes.dumpRoutes" href="#BML.data.routes.dumpRoutes">dumpRoutes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="BML.data.routes.RoutesDump" href="#BML.data.routes.RoutesDump">RoutesDump</a></code></h4>
<ul class="">
<li><code><a title="BML.data.routes.RoutesDump.buildRoutesDump" href="#BML.data.routes.RoutesDump.buildRoutesDump">buildRoutesDump</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.buildRoutesDumpFromUpdates" href="#BML.data.routes.RoutesDump.buildRoutesDumpFromUpdates">buildRoutesDumpFromUpdates</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.buildRoutesDumpFromUpdatesFile" href="#BML.data.routes.RoutesDump.buildRoutesDumpFromUpdatesFile">buildRoutesDumpFromUpdatesFile</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.dumpUpdate" href="#BML.data.routes.RoutesDump.dumpUpdate">dumpUpdate</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.getOutputFilename" href="#BML.data.routes.RoutesDump.getOutputFilename">getOutputFilename</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.getProgress" href="#BML.data.routes.RoutesDump.getProgress">getProgress</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.isRunning" href="#BML.data.routes.RoutesDump.isRunning">isRunning</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.run" href="#BML.data.routes.RoutesDump.run">run</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.saveTo" href="#BML.data.routes.RoutesDump.saveTo">saveTo</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setCollectors" href="#BML.data.routes.RoutesDump.setCollectors">setCollectors</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setInterval" href="#BML.data.routes.RoutesDump.setInterval">setInterval</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setIpVersion" href="#BML.data.routes.RoutesDump.setIpVersion">setIpVersion</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setProjects" href="#BML.data.routes.RoutesDump.setProjects">setProjects</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setUpdates" href="#BML.data.routes.RoutesDump.setUpdates">setUpdates</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.setUpdatesFile" href="#BML.data.routes.RoutesDump.setUpdatesFile">setUpdatesFile</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.startStream" href="#BML.data.routes.RoutesDump.startStream">startStream</a></code></li>
<li><code><a title="BML.data.routes.RoutesDump.stop" href="#BML.data.routes.RoutesDump.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>