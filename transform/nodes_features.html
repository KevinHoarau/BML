<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>BML.transform.nodes_features API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>BML.transform.nodes_features</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from BML.transform import Graph, BaseTransform
from BML.utils import ProcessingQueue, timeFormat, printAndLog
import multiprocessing

import networkit as nk
import networkx as nx
import numpy as np

import random
import time
import threading

from networkx import find_cliques


def my_node_clique_number(G, nodes=None, cliques=None):
    &#34;&#34;&#34;Returns the size of the largest maximal clique containing
    each given node.
    Returns a single or list depending on input nodes.
    Optional list of cliques can be input if already computed.
    &#34;&#34;&#34;
    if cliques is None:
        if nodes is not None:
            # Use ego_graph to decrease size of graph
            if isinstance(nodes, list):
                d = {}
                for n in nodes:
                    H = nx.ego_graph(G, n)
                    d[n] = max(len(c) for c in find_cliques(H))
            else:
                H = nx.ego_graph(G, nodes)
                d = max(len(c) for c in find_cliques(H))
            return d
        # nodes is None--find all cliques
        cliques = list(find_cliques(G))
        
    all_nodes = False
    if nodes is None:
        all_nodes = True
        nodes = list(G.nodes())  # none, get entire graph

    if not isinstance(nodes, list):  # check for a list
        v = nodes
        # assume it is a single value
        d = max([len(c) for c in cliques if v in c])
    else:
        d = {}
        
        for v in nodes:
            d[v] = 0

        for c in cliques:
            l = len(c)
            for v in c:
                if(all_nodes or v in nodes):
                    d[v] = max(d[v],l)
    return d


def my_number_of_cliques(G, nodes=None, cliques=None):
    &#34;&#34;&#34;Returns the number of maximal cliques for each node.

    Returns a single or list depending on input nodes.
    Optional list of cliques can be input if already computed.
    &#34;&#34;&#34;
    if cliques is None:
        cliques = list(find_cliques(G))
    
    all_nodes = False
    if nodes is None:
        all_nodes = True
        nodes = list(G.nodes())  # none, get entire graph

    if not isinstance(nodes, list):  # check for a list
        v = nodes
        # assume it is a single value
        numcliq = len([1 for c in cliques if v in c])
    else:
        numcliq = {}
            
        for v in nodes:
            numcliq[v] = 0

        for c in cliques:
            for v in c:
                if(all_nodes or v in nodes):
                    numcliq[v]+=1
        
    return numcliq


def nx2cu(G):
    import cugraph, cudf
    edges = [(int(a),int(b)) for a,b in [*G.edges]]
    edgelistDF = cudf.DataFrame(edges, columns=[&#39;src&#39;,&#39;dst&#39;])
    Gcu = cugraph.from_cudf_edgelist(edgelistDF, source=&#39;src&#39;, destination=&#39;dst&#39;, renumber=True)
    return(Gcu)

def nx2nk(G):
    Gnk = nk.nxadapter.nx2nk(G)
    Gnk.indexEdges()
    return(Gnk)

def dictKeys(d, keys):
    subD = {}
    keys2 = dict(d).keys()
    for k in keys:
        if(k in keys2):
            subD[k] = d[k]
    return(subD)

def valuesDict(values, keys):
    return(dict(zip(keys, values)))

def betweenness(G, nodes):
    d = nx.betweenness_centrality(G)
    return(dictKeys(d,nodes))

def betweenness_nk(G, Gnk, nodes):
    d = nk.centrality.Betweenness(Gnk,normalized=True).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def load(G, nodes):
    d = nx.load_centrality(G)
    return(dictKeys(d, nodes))

def closeness(G, nodes):
    v = [nx.closeness_centrality(G, u=n) for n in nodes]
    return(valuesDict(v, nodes))

def closeness_nk(G, Gnk, nodes):
    d = nk.centrality.Closeness(Gnk, False, False).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def approx_closeness_nk(G, Gnk, nodes):
    d = nk.centrality.ApproxCloseness(Gnk, len(nodes)).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def harmonic(G, nodes):
    d = nx.harmonic_centrality(G, nbunch=nodes)
    return(d)

def harmonic_nk(G, Gnk, nodes):
    d = nk.centrality.HarmonicCloseness(Gnk, normalized=False).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def degree(G, nodes):
    d = G.degree
    return(dictKeys(d,nodes))

def degree_centrality(G, nodes):
    d = nx.degree_centrality(G)
    return(dictKeys(d,nodes))

def degree_centrality_nk(G, Gnk, nodes):
    d = nk.centrality.DegreeCentrality(Gnk, normalized=True).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def eigenvector(G, nodes):
    d = nx.eigenvector_centrality(G)
    return(dictKeys(d,nodes))

def eigenvector_nk(G, Gnk, nodes):
    d = nk.centrality.EigenvectorCentrality(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def pagerank(G, nodes):
    d = nx.pagerank(G)
    return(dictKeys(d,nodes))

def pagerank_nk(G, Gnk, nodes):
    d = nk.centrality.PageRank(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def number_of_cliques(G, nodes):
    if(nodes==G.nodes):
        d = my_number_of_cliques(G)
    else:
        d = my_number_of_cliques(G, nodes=list(nodes))
    return(dictKeys(d, nodes))

def number_of_cliques_nk(G, Gnk, nodes):
    cliques = nk.clique.MaximalCliques(Gnk).run().getCliques()
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            d[n] = len([1 for c in cliques if v in c])
    return(d)

def node_clique_number(G, nodes):
    if(nodes==G.nodes):
        d = my_node_clique_number(G)
    else:
        d = my_node_clique_number(G, nodes=list(nodes))
    return(dictKeys(d, nodes))

def node_clique_number_nk(G, Gnk, nodes):
    cliques = nk.clique.MaximalCliques(Gnk).run().getCliques()
    v = {}
    for node in Gnk.iterNodes():
        v[node] = 0

    for clique in cliques:
        l = len(clique)
        for node in clique:
            v[node] = max(v[node], l)
    return(dictKeys(valuesDict(v.values(), G.nodes), nodes))

def clustering(G, nodes):
    d = nx.clustering(G, nodes=nodes)
    return(dictKeys(d,nodes))

def clustering_nk(G, Gnk, nodes):
    d = nk.centrality.LocalClusteringCoefficient(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def triangles(G, nodes):
    d = nx.triangles(G, nodes=nodes)
    return(dictKeys(d,nodes))

def triangles_nk(G, Gnk, nodes):
    d = nk.sparsification.TriangleEdgeScore(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))

def square_clustering(G, nodes):
    d = nx.square_clustering(G, nodes=nodes)
    return(dictKeys(d,nodes))

def average_neighbor_degree(G, nodes):
    d = nx.average_neighbor_degree(G, nodes=nodes)
    return(dictKeys(d,nodes))

def eccentricity(G, nodes):
    v = [nx.eccentricity(G, v=n) for n in nodes]
    return(valuesDict(v, nodes))

def eccentricity_nk(G, Gnk, nodes):
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            _,d[n] = nk.distance.Eccentricity.getValue(Gnk,v)
    return(d)

def local_efficiency(G, nodes):
    v = [nx.global_efficiency(G.subgraph(G[n])) for n in nodes]
    return(valuesDict(v, nodes))

def global_efficiency_nk(Gnk):
    n = Gnk.numberOfNodes()
    denom = n * (n - 1)
    if denom != 0:
        g_eff = 0
        lengths = nk.distance.APSP(Gnk).run().getDistances()
        for l in lengths:
            for distance in l:
                if distance &gt; 0:
                    g_eff += 1 / distance
        g_eff /= denom
    else:
        g_eff = 0
    return g_eff

def local_efficiency_nk(G, Gnk, nodes):
    v = [global_efficiency_nk(nx2nk(G.subgraph(G[n]))) for n in nodes]
    return(valuesDict(v, nodes))

def average_shortest_path_length(G, nodes):
    def average_shortest_path_length_node(G, n):
        return(np.mean(list(nx.single_source_shortest_path_length(G,n).values())))
    v = [average_shortest_path_length_node(G, n) for n in nodes]
    return(valuesDict(v, nodes))

def average_shortest_path_length_nk(G, Gnk, nodes):
    def average_shortest_path_length_node(Gnk, n):
        return(np.mean(nk.distance.Dijkstra(Gnk, n).run().getDistances()))
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            d[n] = average_shortest_path_length_node(Gnk, v)
    return(d)

def connectivity(G, nodes): # too slow, see approx version
    v = []
    for n in nodes:
        v.append(np.mean([nx.connectivity.local_node_connectivity(G,n,t) for t in nodes]))
    return(valuesDict(v, nodes))

def run(function, results, key, logFiles, verbose,*args):
    if(verbose):
        printAndLog(&#34;Start:%s&#34; % (key), logFiles)
    s = time.time()
    try:
        results[key] = function(*args)
    except Exception as e:
        print(&#34;Error with feature: &#34; + key)
        raise e
    if(verbose):
        printAndLog(&#34;End:%s (%s)&#34; % (key, timeFormat(time.time()-s)), logFiles)

def computeFeatures(features, logFiles, verbose=False):
    results = {}
    for key, value in features.items():
        function, *args = value
        run(function, results, key, logFiles, verbose,*args)
    return(results)

def computeFeaturesParallelized(features, nbProcess, logFiles, verbose=False):
    
    manager = multiprocessing.Manager()
    results = manager.dict()
    
    pq = ProcessingQueue(nbProcess=nbProcess)
    
    for key, value in features.items():
        function, *args = value
        pq.addProcess(target=run, args=(function, results, key, logFiles, verbose,*args))
    
    pq.run()
    
    r_copy = {}
    for k in list(features.keys()):
        r_copy[k] = results[k].copy()
        del results[k] 
    
    return(r_copy)

def removedExcludedFeatures(features, excluded, included):
    if(len(included)&gt;0):
        for key in list(features.keys()):
            if(not key in included):
                del features[key]
    else:
        for key in excluded:
            if(key in features):
                del features[key]
    return(features)


class NodesFeatures(Graph):
    
    fileExtension = &#34;.json&#34;
    
    def __init__(self, primingFile, dataFile, params, outFolder, logFiles):
        
        self.params[&#34;use_networkit&#34;] = True
        self.params[&#34;all_nodes&#34;] = True
        self.params[&#34;nodes&#34;] = None
        self.params[&#34;exclude_features&#34;] = [] # Excluded by default
        self.params[&#34;include_features&#34;] = [
            &#39;degree&#39;, &#39;degree_centrality&#39;, &#39;average_neighbor_degree&#39;, &#39;node_clique_number&#39;, 
            &#39;number_of_cliques&#39;, &#39;eigenvector&#39;, &#39;pagerank&#39;, &#39;clustering&#39;, &#39;triangles&#39;
        ]
        self.params[&#34;verbose&#34;] = False
        self.params[&#34;nbProcessFeatures&#34;] = multiprocessing.cpu_count()

        Graph.__init__(self, primingFile, dataFile, params, outFolder, logFiles)

    def save(self):
        BaseTransform.save(self)
        
    def getNodes(self, G):
        nodes = self.params[&#34;nodes&#34;]

        if(nodes is None):
            if(not self.params[&#34;all_nodes&#34;]):
                core_number = nx.core_number(G)
                k = np.percentile(list(core_number.values()),98)
                G = nx.k_core(G, k, core_number)

            nodes = G.nodes
            
        return(G, nodes)
            
    def getFeatures(self, G, nodes):
        
        features_nx = {}
        features_nk = {}
        
        features_nx[&#34;load&#34;] = (load, G, nodes)
        features_nx[&#34;degree&#34;] = (degree, G, nodes) # already fast with nx
        features_nx[&#34;degree_centrality&#34;] = (degree_centrality, G, nodes) # already fast with nx
        features_nx[&#34;square_clustering&#34;] = (square_clustering, G, nodes)
        features_nx[&#34;average_neighbor_degree&#34;] = (average_neighbor_degree, G, nodes)
        features_nx[&#34;node_clique_number&#34;] = (node_clique_number, G, nodes) # Fast with my fix
        features_nx[&#34;number_of_cliques&#34;] = (number_of_cliques, G, nodes) # Fast with my fix
        
        if(self.params[&#34;use_networkit&#34;]):
            Gnk = nx2nk(G)
            features_nk[&#34;closeness&#34;] = (closeness_nk, G, Gnk, nodes)
            features_nk[&#34;betweenness&#34;] = (betweenness_nk, G, Gnk, nodes)
            features_nk[&#34;local_efficiency&#34;] = (local_efficiency_nk, G, Gnk, nodes)
            features_nk[&#34;harmonic&#34;] = (harmonic_nk, G, Gnk, nodes) 
            features_nk[&#34;eigenvector&#34;] = (eigenvector_nk, G, Gnk, nodes)
            features_nk[&#34;pagerank&#34;] = (pagerank_nk, G, Gnk, nodes)
            features_nk[&#34;clustering&#34;] = (clustering_nk, G, Gnk, nodes)
            features_nk[&#34;triangles&#34;] = (triangles_nk, G, Gnk, nodes)
            features_nk[&#34;eccentricity&#34;] = (eccentricity_nk, G, Gnk, nodes)
            features_nk[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length_nk, G, Gnk, nodes)
        else:
            features_nx[&#34;closeness&#34;] = (closeness, G, nodes) 
            features_nx[&#34;betweenness&#34;] = (betweenness, G, nodes)
            features_nx[&#34;local_efficiency&#34;] = (local_efficiency, G, nodes)
            features_nx[&#34;harmonic&#34;] = (harmonic, G, nodes) 
            features_nx[&#34;eigenvector&#34;] = (eigenvector, G, nodes)
            features_nx[&#34;pagerank&#34;] = (pagerank, G, nodes)
            features_nx[&#34;clustering&#34;] = (clustering, G, nodes)
            features_nx[&#34;triangles&#34;] = (triangles, G, nodes)
            features_nx[&#34;eccentricity&#34;] = (eccentricity, G, nodes)
            features_nx[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length, G, nodes)
            
        return(features_nx, features_nk)
            
    def computeFeatures(self, G, features_nx, features_nk):
        
        results = {}
        
        def func(results,features_nk,verbose):
                results.update(computeFeatures(features_nk, self.logFiles, verbose))    
        thread = threading.Thread(target=func, args=(results, features_nk, self.params[&#34;verbose&#34;]))
        thread.start()
        
        results.update(computeFeaturesParallelized(features_nx, self.params[&#34;nbProcessFeatures&#34;], self.logFiles, self.params[&#34;verbose&#34;]))
        thread.join()
        
        return(results)

    def transforms(self, index, G):
        
        G, nodes = self.getNodes(G)
        
        features_nx, features_nk = self.getFeatures(G, nodes)
        
        features_nx = removedExcludedFeatures(features_nx, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])
        features_nk = removedExcludedFeatures(features_nk, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])

        results = self.computeFeatures(G, features_nx, features_nk)
        
        return(results)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="BML.transform.nodes_features.approx_closeness_nk"><code class="name flex">
<span>def <span class="ident">approx_closeness_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approx_closeness_nk(G, Gnk, nodes):
    d = nk.centrality.ApproxCloseness(Gnk, len(nodes)).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.average_neighbor_degree"><code class="name flex">
<span>def <span class="ident">average_neighbor_degree</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_neighbor_degree(G, nodes):
    d = nx.average_neighbor_degree(G, nodes=nodes)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.average_shortest_path_length"><code class="name flex">
<span>def <span class="ident">average_shortest_path_length</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_shortest_path_length(G, nodes):
    def average_shortest_path_length_node(G, n):
        return(np.mean(list(nx.single_source_shortest_path_length(G,n).values())))
    v = [average_shortest_path_length_node(G, n) for n in nodes]
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.average_shortest_path_length_nk"><code class="name flex">
<span>def <span class="ident">average_shortest_path_length_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def average_shortest_path_length_nk(G, Gnk, nodes):
    def average_shortest_path_length_node(Gnk, n):
        return(np.mean(nk.distance.Dijkstra(Gnk, n).run().getDistances()))
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            d[n] = average_shortest_path_length_node(Gnk, v)
    return(d)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.betweenness"><code class="name flex">
<span>def <span class="ident">betweenness</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def betweenness(G, nodes):
    d = nx.betweenness_centrality(G)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.betweenness_nk"><code class="name flex">
<span>def <span class="ident">betweenness_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def betweenness_nk(G, Gnk, nodes):
    d = nk.centrality.Betweenness(Gnk,normalized=True).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.closeness"><code class="name flex">
<span>def <span class="ident">closeness</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeness(G, nodes):
    v = [nx.closeness_centrality(G, u=n) for n in nodes]
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.closeness_nk"><code class="name flex">
<span>def <span class="ident">closeness_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeness_nk(G, Gnk, nodes):
    d = nk.centrality.Closeness(Gnk, False, False).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.clustering"><code class="name flex">
<span>def <span class="ident">clustering</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clustering(G, nodes):
    d = nx.clustering(G, nodes=nodes)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.clustering_nk"><code class="name flex">
<span>def <span class="ident">clustering_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clustering_nk(G, Gnk, nodes):
    d = nk.centrality.LocalClusteringCoefficient(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.computeFeatures"><code class="name flex">
<span>def <span class="ident">computeFeatures</span></span>(<span>features, logFiles, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeFeatures(features, logFiles, verbose=False):
    results = {}
    for key, value in features.items():
        function, *args = value
        run(function, results, key, logFiles, verbose,*args)
    return(results)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.computeFeaturesParallelized"><code class="name flex">
<span>def <span class="ident">computeFeaturesParallelized</span></span>(<span>features, nbProcess, logFiles, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeFeaturesParallelized(features, nbProcess, logFiles, verbose=False):
    
    manager = multiprocessing.Manager()
    results = manager.dict()
    
    pq = ProcessingQueue(nbProcess=nbProcess)
    
    for key, value in features.items():
        function, *args = value
        pq.addProcess(target=run, args=(function, results, key, logFiles, verbose,*args))
    
    pq.run()
    
    r_copy = {}
    for k in list(features.keys()):
        r_copy[k] = results[k].copy()
        del results[k] 
    
    return(r_copy)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.connectivity"><code class="name flex">
<span>def <span class="ident">connectivity</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connectivity(G, nodes): # too slow, see approx version
    v = []
    for n in nodes:
        v.append(np.mean([nx.connectivity.local_node_connectivity(G,n,t) for t in nodes]))
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.degree"><code class="name flex">
<span>def <span class="ident">degree</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degree(G, nodes):
    d = G.degree
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.degree_centrality"><code class="name flex">
<span>def <span class="ident">degree_centrality</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degree_centrality(G, nodes):
    d = nx.degree_centrality(G)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.degree_centrality_nk"><code class="name flex">
<span>def <span class="ident">degree_centrality_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def degree_centrality_nk(G, Gnk, nodes):
    d = nk.centrality.DegreeCentrality(Gnk, normalized=True).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.dictKeys"><code class="name flex">
<span>def <span class="ident">dictKeys</span></span>(<span>d, keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dictKeys(d, keys):
    subD = {}
    keys2 = dict(d).keys()
    for k in keys:
        if(k in keys2):
            subD[k] = d[k]
    return(subD)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.eccentricity"><code class="name flex">
<span>def <span class="ident">eccentricity</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eccentricity(G, nodes):
    v = [nx.eccentricity(G, v=n) for n in nodes]
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.eccentricity_nk"><code class="name flex">
<span>def <span class="ident">eccentricity_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eccentricity_nk(G, Gnk, nodes):
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            _,d[n] = nk.distance.Eccentricity.getValue(Gnk,v)
    return(d)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.eigenvector"><code class="name flex">
<span>def <span class="ident">eigenvector</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eigenvector(G, nodes):
    d = nx.eigenvector_centrality(G)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.eigenvector_nk"><code class="name flex">
<span>def <span class="ident">eigenvector_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eigenvector_nk(G, Gnk, nodes):
    d = nk.centrality.EigenvectorCentrality(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.global_efficiency_nk"><code class="name flex">
<span>def <span class="ident">global_efficiency_nk</span></span>(<span>Gnk)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_efficiency_nk(Gnk):
    n = Gnk.numberOfNodes()
    denom = n * (n - 1)
    if denom != 0:
        g_eff = 0
        lengths = nk.distance.APSP(Gnk).run().getDistances()
        for l in lengths:
            for distance in l:
                if distance &gt; 0:
                    g_eff += 1 / distance
        g_eff /= denom
    else:
        g_eff = 0
    return g_eff</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.harmonic"><code class="name flex">
<span>def <span class="ident">harmonic</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonic(G, nodes):
    d = nx.harmonic_centrality(G, nbunch=nodes)
    return(d)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.harmonic_nk"><code class="name flex">
<span>def <span class="ident">harmonic_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonic_nk(G, Gnk, nodes):
    d = nk.centrality.HarmonicCloseness(Gnk, normalized=False).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(G, nodes):
    d = nx.load_centrality(G)
    return(dictKeys(d, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.local_efficiency"><code class="name flex">
<span>def <span class="ident">local_efficiency</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_efficiency(G, nodes):
    v = [nx.global_efficiency(G.subgraph(G[n])) for n in nodes]
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.local_efficiency_nk"><code class="name flex">
<span>def <span class="ident">local_efficiency_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_efficiency_nk(G, Gnk, nodes):
    v = [global_efficiency_nk(nx2nk(G.subgraph(G[n]))) for n in nodes]
    return(valuesDict(v, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.my_node_clique_number"><code class="name flex">
<span>def <span class="ident">my_node_clique_number</span></span>(<span>G, nodes=None, cliques=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the size of the largest maximal clique containing
each given node.
Returns a single or list depending on input nodes.
Optional list of cliques can be input if already computed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def my_node_clique_number(G, nodes=None, cliques=None):
    &#34;&#34;&#34;Returns the size of the largest maximal clique containing
    each given node.
    Returns a single or list depending on input nodes.
    Optional list of cliques can be input if already computed.
    &#34;&#34;&#34;
    if cliques is None:
        if nodes is not None:
            # Use ego_graph to decrease size of graph
            if isinstance(nodes, list):
                d = {}
                for n in nodes:
                    H = nx.ego_graph(G, n)
                    d[n] = max(len(c) for c in find_cliques(H))
            else:
                H = nx.ego_graph(G, nodes)
                d = max(len(c) for c in find_cliques(H))
            return d
        # nodes is None--find all cliques
        cliques = list(find_cliques(G))
        
    all_nodes = False
    if nodes is None:
        all_nodes = True
        nodes = list(G.nodes())  # none, get entire graph

    if not isinstance(nodes, list):  # check for a list
        v = nodes
        # assume it is a single value
        d = max([len(c) for c in cliques if v in c])
    else:
        d = {}
        
        for v in nodes:
            d[v] = 0

        for c in cliques:
            l = len(c)
            for v in c:
                if(all_nodes or v in nodes):
                    d[v] = max(d[v],l)
    return d</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.my_number_of_cliques"><code class="name flex">
<span>def <span class="ident">my_number_of_cliques</span></span>(<span>G, nodes=None, cliques=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of maximal cliques for each node.</p>
<p>Returns a single or list depending on input nodes.
Optional list of cliques can be input if already computed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def my_number_of_cliques(G, nodes=None, cliques=None):
    &#34;&#34;&#34;Returns the number of maximal cliques for each node.

    Returns a single or list depending on input nodes.
    Optional list of cliques can be input if already computed.
    &#34;&#34;&#34;
    if cliques is None:
        cliques = list(find_cliques(G))
    
    all_nodes = False
    if nodes is None:
        all_nodes = True
        nodes = list(G.nodes())  # none, get entire graph

    if not isinstance(nodes, list):  # check for a list
        v = nodes
        # assume it is a single value
        numcliq = len([1 for c in cliques if v in c])
    else:
        numcliq = {}
            
        for v in nodes:
            numcliq[v] = 0

        for c in cliques:
            for v in c:
                if(all_nodes or v in nodes):
                    numcliq[v]+=1
        
    return numcliq</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.node_clique_number"><code class="name flex">
<span>def <span class="ident">node_clique_number</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_clique_number(G, nodes):
    if(nodes==G.nodes):
        d = my_node_clique_number(G)
    else:
        d = my_node_clique_number(G, nodes=list(nodes))
    return(dictKeys(d, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.node_clique_number_nk"><code class="name flex">
<span>def <span class="ident">node_clique_number_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_clique_number_nk(G, Gnk, nodes):
    cliques = nk.clique.MaximalCliques(Gnk).run().getCliques()
    v = {}
    for node in Gnk.iterNodes():
        v[node] = 0

    for clique in cliques:
        l = len(clique)
        for node in clique:
            v[node] = max(v[node], l)
    return(dictKeys(valuesDict(v.values(), G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.number_of_cliques"><code class="name flex">
<span>def <span class="ident">number_of_cliques</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number_of_cliques(G, nodes):
    if(nodes==G.nodes):
        d = my_number_of_cliques(G)
    else:
        d = my_number_of_cliques(G, nodes=list(nodes))
    return(dictKeys(d, nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.number_of_cliques_nk"><code class="name flex">
<span>def <span class="ident">number_of_cliques_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number_of_cliques_nk(G, Gnk, nodes):
    cliques = nk.clique.MaximalCliques(Gnk).run().getCliques()
    d = {}
    for n,v in zip(G.nodes, Gnk.iterNodes()):
        if(n in nodes):
            d[n] = len([1 for c in cliques if v in c])
    return(d)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.nx2cu"><code class="name flex">
<span>def <span class="ident">nx2cu</span></span>(<span>G)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nx2cu(G):
    import cugraph, cudf
    edges = [(int(a),int(b)) for a,b in [*G.edges]]
    edgelistDF = cudf.DataFrame(edges, columns=[&#39;src&#39;,&#39;dst&#39;])
    Gcu = cugraph.from_cudf_edgelist(edgelistDF, source=&#39;src&#39;, destination=&#39;dst&#39;, renumber=True)
    return(Gcu)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.nx2nk"><code class="name flex">
<span>def <span class="ident">nx2nk</span></span>(<span>G)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nx2nk(G):
    Gnk = nk.nxadapter.nx2nk(G)
    Gnk.indexEdges()
    return(Gnk)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.pagerank"><code class="name flex">
<span>def <span class="ident">pagerank</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pagerank(G, nodes):
    d = nx.pagerank(G)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.pagerank_nk"><code class="name flex">
<span>def <span class="ident">pagerank_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pagerank_nk(G, Gnk, nodes):
    d = nk.centrality.PageRank(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.removedExcludedFeatures"><code class="name flex">
<span>def <span class="ident">removedExcludedFeatures</span></span>(<span>features, excluded, included)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removedExcludedFeatures(features, excluded, included):
    if(len(included)&gt;0):
        for key in list(features.keys()):
            if(not key in included):
                del features[key]
    else:
        for key in excluded:
            if(key in features):
                del features[key]
    return(features)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>function, results, key, logFiles, verbose, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(function, results, key, logFiles, verbose,*args):
    if(verbose):
        printAndLog(&#34;Start:%s&#34; % (key), logFiles)
    s = time.time()
    try:
        results[key] = function(*args)
    except Exception as e:
        print(&#34;Error with feature: &#34; + key)
        raise e
    if(verbose):
        printAndLog(&#34;End:%s (%s)&#34; % (key, timeFormat(time.time()-s)), logFiles)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.square_clustering"><code class="name flex">
<span>def <span class="ident">square_clustering</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def square_clustering(G, nodes):
    d = nx.square_clustering(G, nodes=nodes)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.triangles"><code class="name flex">
<span>def <span class="ident">triangles</span></span>(<span>G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangles(G, nodes):
    d = nx.triangles(G, nodes=nodes)
    return(dictKeys(d,nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.triangles_nk"><code class="name flex">
<span>def <span class="ident">triangles_nk</span></span>(<span>G, Gnk, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangles_nk(G, Gnk, nodes):
    d = nk.sparsification.TriangleEdgeScore(Gnk).run().scores()
    return(dictKeys(valuesDict(d, G.nodes), nodes))</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.valuesDict"><code class="name flex">
<span>def <span class="ident">valuesDict</span></span>(<span>values, keys)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valuesDict(values, keys):
    return(dict(zip(keys, values)))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="BML.transform.nodes_features.NodesFeatures"><code class="flex name class">
<span>class <span class="ident">NodesFeatures</span></span>
<span>(</span><span>primingFile, dataFile, params, outFolder, logFiles)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodesFeatures(Graph):
    
    fileExtension = &#34;.json&#34;
    
    def __init__(self, primingFile, dataFile, params, outFolder, logFiles):
        
        self.params[&#34;use_networkit&#34;] = True
        self.params[&#34;all_nodes&#34;] = True
        self.params[&#34;nodes&#34;] = None
        self.params[&#34;exclude_features&#34;] = [] # Excluded by default
        self.params[&#34;include_features&#34;] = [
            &#39;degree&#39;, &#39;degree_centrality&#39;, &#39;average_neighbor_degree&#39;, &#39;node_clique_number&#39;, 
            &#39;number_of_cliques&#39;, &#39;eigenvector&#39;, &#39;pagerank&#39;, &#39;clustering&#39;, &#39;triangles&#39;
        ]
        self.params[&#34;verbose&#34;] = False
        self.params[&#34;nbProcessFeatures&#34;] = multiprocessing.cpu_count()

        Graph.__init__(self, primingFile, dataFile, params, outFolder, logFiles)

    def save(self):
        BaseTransform.save(self)
        
    def getNodes(self, G):
        nodes = self.params[&#34;nodes&#34;]

        if(nodes is None):
            if(not self.params[&#34;all_nodes&#34;]):
                core_number = nx.core_number(G)
                k = np.percentile(list(core_number.values()),98)
                G = nx.k_core(G, k, core_number)

            nodes = G.nodes
            
        return(G, nodes)
            
    def getFeatures(self, G, nodes):
        
        features_nx = {}
        features_nk = {}
        
        features_nx[&#34;load&#34;] = (load, G, nodes)
        features_nx[&#34;degree&#34;] = (degree, G, nodes) # already fast with nx
        features_nx[&#34;degree_centrality&#34;] = (degree_centrality, G, nodes) # already fast with nx
        features_nx[&#34;square_clustering&#34;] = (square_clustering, G, nodes)
        features_nx[&#34;average_neighbor_degree&#34;] = (average_neighbor_degree, G, nodes)
        features_nx[&#34;node_clique_number&#34;] = (node_clique_number, G, nodes) # Fast with my fix
        features_nx[&#34;number_of_cliques&#34;] = (number_of_cliques, G, nodes) # Fast with my fix
        
        if(self.params[&#34;use_networkit&#34;]):
            Gnk = nx2nk(G)
            features_nk[&#34;closeness&#34;] = (closeness_nk, G, Gnk, nodes)
            features_nk[&#34;betweenness&#34;] = (betweenness_nk, G, Gnk, nodes)
            features_nk[&#34;local_efficiency&#34;] = (local_efficiency_nk, G, Gnk, nodes)
            features_nk[&#34;harmonic&#34;] = (harmonic_nk, G, Gnk, nodes) 
            features_nk[&#34;eigenvector&#34;] = (eigenvector_nk, G, Gnk, nodes)
            features_nk[&#34;pagerank&#34;] = (pagerank_nk, G, Gnk, nodes)
            features_nk[&#34;clustering&#34;] = (clustering_nk, G, Gnk, nodes)
            features_nk[&#34;triangles&#34;] = (triangles_nk, G, Gnk, nodes)
            features_nk[&#34;eccentricity&#34;] = (eccentricity_nk, G, Gnk, nodes)
            features_nk[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length_nk, G, Gnk, nodes)
        else:
            features_nx[&#34;closeness&#34;] = (closeness, G, nodes) 
            features_nx[&#34;betweenness&#34;] = (betweenness, G, nodes)
            features_nx[&#34;local_efficiency&#34;] = (local_efficiency, G, nodes)
            features_nx[&#34;harmonic&#34;] = (harmonic, G, nodes) 
            features_nx[&#34;eigenvector&#34;] = (eigenvector, G, nodes)
            features_nx[&#34;pagerank&#34;] = (pagerank, G, nodes)
            features_nx[&#34;clustering&#34;] = (clustering, G, nodes)
            features_nx[&#34;triangles&#34;] = (triangles, G, nodes)
            features_nx[&#34;eccentricity&#34;] = (eccentricity, G, nodes)
            features_nx[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length, G, nodes)
            
        return(features_nx, features_nk)
            
    def computeFeatures(self, G, features_nx, features_nk):
        
        results = {}
        
        def func(results,features_nk,verbose):
                results.update(computeFeatures(features_nk, self.logFiles, verbose))    
        thread = threading.Thread(target=func, args=(results, features_nk, self.params[&#34;verbose&#34;]))
        thread.start()
        
        results.update(computeFeaturesParallelized(features_nx, self.params[&#34;nbProcessFeatures&#34;], self.logFiles, self.params[&#34;verbose&#34;]))
        thread.join()
        
        return(results)

    def transforms(self, index, G):
        
        G, nodes = self.getNodes(G)
        
        features_nx, features_nk = self.getFeatures(G, nodes)
        
        features_nx = removedExcludedFeatures(features_nx, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])
        features_nk = removedExcludedFeatures(features_nk, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])

        results = self.computeFeatures(G, features_nx, features_nk)
        
        return(results)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="BML.transform.graph.Graph" href="graph.html#BML.transform.graph.Graph">Graph</a></li>
<li><a title="BML.transform.base_transform.BaseTransformParallelized" href="base_transform.html#BML.transform.base_transform.BaseTransformParallelized">BaseTransformParallelized</a></li>
<li><a title="BML.transform.base_transform.BaseTransform" href="base_transform.html#BML.transform.base_transform.BaseTransform">BaseTransform</a></li>
<li><a title="BML.utils.bml_process.BmlProcess" href="../utils/bml_process.html#BML.utils.bml_process.BmlProcess">BmlProcess</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="BML.transform.graph_features.GraphFeatures" href="graph_features.html#BML.transform.graph_features.GraphFeatures">GraphFeatures</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="BML.transform.nodes_features.NodesFeatures.fileExtension"><code class="name">var <span class="ident">fileExtension</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="BML.transform.nodes_features.NodesFeatures.computeFeatures"><code class="name flex">
<span>def <span class="ident">computeFeatures</span></span>(<span>self, G, features_nx, features_nk)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeFeatures(self, G, features_nx, features_nk):
    
    results = {}
    
    def func(results,features_nk,verbose):
            results.update(computeFeatures(features_nk, self.logFiles, verbose))    
    thread = threading.Thread(target=func, args=(results, features_nk, self.params[&#34;verbose&#34;]))
    thread.start()
    
    results.update(computeFeaturesParallelized(features_nx, self.params[&#34;nbProcessFeatures&#34;], self.logFiles, self.params[&#34;verbose&#34;]))
    thread.join()
    
    return(results)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.NodesFeatures.getFeatures"><code class="name flex">
<span>def <span class="ident">getFeatures</span></span>(<span>self, G, nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFeatures(self, G, nodes):
    
    features_nx = {}
    features_nk = {}
    
    features_nx[&#34;load&#34;] = (load, G, nodes)
    features_nx[&#34;degree&#34;] = (degree, G, nodes) # already fast with nx
    features_nx[&#34;degree_centrality&#34;] = (degree_centrality, G, nodes) # already fast with nx
    features_nx[&#34;square_clustering&#34;] = (square_clustering, G, nodes)
    features_nx[&#34;average_neighbor_degree&#34;] = (average_neighbor_degree, G, nodes)
    features_nx[&#34;node_clique_number&#34;] = (node_clique_number, G, nodes) # Fast with my fix
    features_nx[&#34;number_of_cliques&#34;] = (number_of_cliques, G, nodes) # Fast with my fix
    
    if(self.params[&#34;use_networkit&#34;]):
        Gnk = nx2nk(G)
        features_nk[&#34;closeness&#34;] = (closeness_nk, G, Gnk, nodes)
        features_nk[&#34;betweenness&#34;] = (betweenness_nk, G, Gnk, nodes)
        features_nk[&#34;local_efficiency&#34;] = (local_efficiency_nk, G, Gnk, nodes)
        features_nk[&#34;harmonic&#34;] = (harmonic_nk, G, Gnk, nodes) 
        features_nk[&#34;eigenvector&#34;] = (eigenvector_nk, G, Gnk, nodes)
        features_nk[&#34;pagerank&#34;] = (pagerank_nk, G, Gnk, nodes)
        features_nk[&#34;clustering&#34;] = (clustering_nk, G, Gnk, nodes)
        features_nk[&#34;triangles&#34;] = (triangles_nk, G, Gnk, nodes)
        features_nk[&#34;eccentricity&#34;] = (eccentricity_nk, G, Gnk, nodes)
        features_nk[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length_nk, G, Gnk, nodes)
    else:
        features_nx[&#34;closeness&#34;] = (closeness, G, nodes) 
        features_nx[&#34;betweenness&#34;] = (betweenness, G, nodes)
        features_nx[&#34;local_efficiency&#34;] = (local_efficiency, G, nodes)
        features_nx[&#34;harmonic&#34;] = (harmonic, G, nodes) 
        features_nx[&#34;eigenvector&#34;] = (eigenvector, G, nodes)
        features_nx[&#34;pagerank&#34;] = (pagerank, G, nodes)
        features_nx[&#34;clustering&#34;] = (clustering, G, nodes)
        features_nx[&#34;triangles&#34;] = (triangles, G, nodes)
        features_nx[&#34;eccentricity&#34;] = (eccentricity, G, nodes)
        features_nx[&#34;average_shortest_path_length&#34;] = (average_shortest_path_length, G, nodes)
        
    return(features_nx, features_nk)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.NodesFeatures.getNodes"><code class="name flex">
<span>def <span class="ident">getNodes</span></span>(<span>self, G)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNodes(self, G):
    nodes = self.params[&#34;nodes&#34;]

    if(nodes is None):
        if(not self.params[&#34;all_nodes&#34;]):
            core_number = nx.core_number(G)
            k = np.percentile(list(core_number.values()),98)
            G = nx.k_core(G, k, core_number)

        nodes = G.nodes
        
    return(G, nodes)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.NodesFeatures.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    BaseTransform.save(self)</code></pre>
</details>
</dd>
<dt id="BML.transform.nodes_features.NodesFeatures.transforms"><code class="name flex">
<span>def <span class="ident">transforms</span></span>(<span>self, index, G)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transforms(self, index, G):
    
    G, nodes = self.getNodes(G)
    
    features_nx, features_nk = self.getFeatures(G, nodes)
    
    features_nx = removedExcludedFeatures(features_nx, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])
    features_nk = removedExcludedFeatures(features_nk, self.params[&#34;exclude_features&#34;], self.params[&#34;include_features&#34;])

    results = self.computeFeatures(G, features_nx, features_nk)
    
    return(results)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="https://kevinhoarau.github.io/BML/" style="font-size:4em;color:#058">BML</a>
<hr style="margin-top:30px;margin-bottom:30px;">
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="BML.transform" href="index.html">BML.transform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="BML.transform.nodes_features.approx_closeness_nk" href="#BML.transform.nodes_features.approx_closeness_nk">approx_closeness_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.average_neighbor_degree" href="#BML.transform.nodes_features.average_neighbor_degree">average_neighbor_degree</a></code></li>
<li><code><a title="BML.transform.nodes_features.average_shortest_path_length" href="#BML.transform.nodes_features.average_shortest_path_length">average_shortest_path_length</a></code></li>
<li><code><a title="BML.transform.nodes_features.average_shortest_path_length_nk" href="#BML.transform.nodes_features.average_shortest_path_length_nk">average_shortest_path_length_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.betweenness" href="#BML.transform.nodes_features.betweenness">betweenness</a></code></li>
<li><code><a title="BML.transform.nodes_features.betweenness_nk" href="#BML.transform.nodes_features.betweenness_nk">betweenness_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.closeness" href="#BML.transform.nodes_features.closeness">closeness</a></code></li>
<li><code><a title="BML.transform.nodes_features.closeness_nk" href="#BML.transform.nodes_features.closeness_nk">closeness_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.clustering" href="#BML.transform.nodes_features.clustering">clustering</a></code></li>
<li><code><a title="BML.transform.nodes_features.clustering_nk" href="#BML.transform.nodes_features.clustering_nk">clustering_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.computeFeatures" href="#BML.transform.nodes_features.computeFeatures">computeFeatures</a></code></li>
<li><code><a title="BML.transform.nodes_features.computeFeaturesParallelized" href="#BML.transform.nodes_features.computeFeaturesParallelized">computeFeaturesParallelized</a></code></li>
<li><code><a title="BML.transform.nodes_features.connectivity" href="#BML.transform.nodes_features.connectivity">connectivity</a></code></li>
<li><code><a title="BML.transform.nodes_features.degree" href="#BML.transform.nodes_features.degree">degree</a></code></li>
<li><code><a title="BML.transform.nodes_features.degree_centrality" href="#BML.transform.nodes_features.degree_centrality">degree_centrality</a></code></li>
<li><code><a title="BML.transform.nodes_features.degree_centrality_nk" href="#BML.transform.nodes_features.degree_centrality_nk">degree_centrality_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.dictKeys" href="#BML.transform.nodes_features.dictKeys">dictKeys</a></code></li>
<li><code><a title="BML.transform.nodes_features.eccentricity" href="#BML.transform.nodes_features.eccentricity">eccentricity</a></code></li>
<li><code><a title="BML.transform.nodes_features.eccentricity_nk" href="#BML.transform.nodes_features.eccentricity_nk">eccentricity_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.eigenvector" href="#BML.transform.nodes_features.eigenvector">eigenvector</a></code></li>
<li><code><a title="BML.transform.nodes_features.eigenvector_nk" href="#BML.transform.nodes_features.eigenvector_nk">eigenvector_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.global_efficiency_nk" href="#BML.transform.nodes_features.global_efficiency_nk">global_efficiency_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.harmonic" href="#BML.transform.nodes_features.harmonic">harmonic</a></code></li>
<li><code><a title="BML.transform.nodes_features.harmonic_nk" href="#BML.transform.nodes_features.harmonic_nk">harmonic_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.load" href="#BML.transform.nodes_features.load">load</a></code></li>
<li><code><a title="BML.transform.nodes_features.local_efficiency" href="#BML.transform.nodes_features.local_efficiency">local_efficiency</a></code></li>
<li><code><a title="BML.transform.nodes_features.local_efficiency_nk" href="#BML.transform.nodes_features.local_efficiency_nk">local_efficiency_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.my_node_clique_number" href="#BML.transform.nodes_features.my_node_clique_number">my_node_clique_number</a></code></li>
<li><code><a title="BML.transform.nodes_features.my_number_of_cliques" href="#BML.transform.nodes_features.my_number_of_cliques">my_number_of_cliques</a></code></li>
<li><code><a title="BML.transform.nodes_features.node_clique_number" href="#BML.transform.nodes_features.node_clique_number">node_clique_number</a></code></li>
<li><code><a title="BML.transform.nodes_features.node_clique_number_nk" href="#BML.transform.nodes_features.node_clique_number_nk">node_clique_number_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.number_of_cliques" href="#BML.transform.nodes_features.number_of_cliques">number_of_cliques</a></code></li>
<li><code><a title="BML.transform.nodes_features.number_of_cliques_nk" href="#BML.transform.nodes_features.number_of_cliques_nk">number_of_cliques_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.nx2cu" href="#BML.transform.nodes_features.nx2cu">nx2cu</a></code></li>
<li><code><a title="BML.transform.nodes_features.nx2nk" href="#BML.transform.nodes_features.nx2nk">nx2nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.pagerank" href="#BML.transform.nodes_features.pagerank">pagerank</a></code></li>
<li><code><a title="BML.transform.nodes_features.pagerank_nk" href="#BML.transform.nodes_features.pagerank_nk">pagerank_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.removedExcludedFeatures" href="#BML.transform.nodes_features.removedExcludedFeatures">removedExcludedFeatures</a></code></li>
<li><code><a title="BML.transform.nodes_features.run" href="#BML.transform.nodes_features.run">run</a></code></li>
<li><code><a title="BML.transform.nodes_features.square_clustering" href="#BML.transform.nodes_features.square_clustering">square_clustering</a></code></li>
<li><code><a title="BML.transform.nodes_features.triangles" href="#BML.transform.nodes_features.triangles">triangles</a></code></li>
<li><code><a title="BML.transform.nodes_features.triangles_nk" href="#BML.transform.nodes_features.triangles_nk">triangles_nk</a></code></li>
<li><code><a title="BML.transform.nodes_features.valuesDict" href="#BML.transform.nodes_features.valuesDict">valuesDict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="BML.transform.nodes_features.NodesFeatures" href="#BML.transform.nodes_features.NodesFeatures">NodesFeatures</a></code></h4>
<ul class="two-column">
<li><code><a title="BML.transform.nodes_features.NodesFeatures.computeFeatures" href="#BML.transform.nodes_features.NodesFeatures.computeFeatures">computeFeatures</a></code></li>
<li><code><a title="BML.transform.nodes_features.NodesFeatures.fileExtension" href="#BML.transform.nodes_features.NodesFeatures.fileExtension">fileExtension</a></code></li>
<li><code><a title="BML.transform.nodes_features.NodesFeatures.getFeatures" href="#BML.transform.nodes_features.NodesFeatures.getFeatures">getFeatures</a></code></li>
<li><code><a title="BML.transform.nodes_features.NodesFeatures.getNodes" href="#BML.transform.nodes_features.NodesFeatures.getNodes">getNodes</a></code></li>
<li><code><a title="BML.transform.nodes_features.NodesFeatures.save" href="#BML.transform.nodes_features.NodesFeatures.save">save</a></code></li>
<li><code><a title="BML.transform.nodes_features.NodesFeatures.transforms" href="#BML.transform.nodes_features.NodesFeatures.transforms">transforms</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>